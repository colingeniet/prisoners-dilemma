\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\usepackage[table]{xcolor}
\usepackage{pgfplots}
\pgfplotsset{width=10cm}

\title{Dilemme du prisonnier \\ Projet Architecture --- Système}
\author{Yoan Geran \and Colin Geniet}
\begin{document}
\maketitle
\tableofcontents

\section*{Introduction}

\section{Dilemme du prisonnier itéré}
\subsection{Usage}
\begin{verbatim}
$ make iterated_prisoner
$ ./iterated_prisoner <iterations>
\end{verbatim}

Ce programme simule toutes les combinaisons des 11 stratégies standard pour \verb|<iterations>| itérations,
et crée \verb|iterated_dilemma.tex| contenant un tableau des scores cumulés.
Voir la table \ref{strat_table} pour un exemple de résultat.

Le programme tente de compiler le fichier \LaTeX{} avec \verb|pdflatex|, et de l'afficher avec \verb|evince|
(modifiable dans \verb|latex_output.h|).

\begin{table}
\caption[Comparaison des stratégies]{Comparaisons des stratégies sur le dilemme du prisonnier itéré.}
\label{strat_table}
\begin{center}
\rowcolors{2}{white}{lightgray}
\begin{tabular}{|c|cccccc|}
\hline
& gent & méch & d-d & méf & d-d dur & ranc \\ \hline
gentille & 3000& 0& 3000& 2997& 3000& 3000\\
méchante & 5000& 1000& 1004& 1000& 1004& 1004\\
donnant-donnant & 3000& 999& 3000& 2500& 3000& 3000\\
méfiante & 3002& 1000& 2500& 1000& 1003& 1003\\
donnant-donnant-dur & 3000& 999& 3000& 1003& 3000& 3000\\
rancunière & 3000& 999& 3000& 1003& 3000& 3000\\
périodique gentille & 3666& 333& 2667& 2664& 1671& 343\\
périodique méchante & 4334& 667& 2003& 1999& 671& 671\\
majorité mou & 3000& 999& 3000& 2500& 3000& 3000\\
majorité dur & 3002& 1000& 2500& 1000& 1003& 1003\\
sondeur & 4996& 999& 1006& 1003& 1006& 1006\\
\hline
\end{tabular}
\\
\rowcolors{2}{white}{lightgray}
\begin{tabular}{|c|cccccc|}
\hline
& p gent & p méch & maj mou & maj dur & sond & total \\ \hline
gentille & 2001& 999& 3000& 2997& 3& 23997\\
méchante & 3668& 2332& 1004& 1000& 1004& 19020\\
donnant-donnant & 2667& 1998& 3000& 2500& 1001& 26665\\
méfiante & 2669& 1999& 2500& 1000& 1003& 18679\\
donnant-donnant-dur & 3331& 2331& 3000& 1003& 1001& 24668\\
rancunière & 3663& 2331& 3000& 1003& 1001& 25000\\
périodique gentille & 2334& 1665& 3666& 3663& 2660& 25332\\
périodique méchante & 3335& 1666& 671& 667& 1999& 18683\\
majorité mou & 2001& 2331& 3000& 2500& 1000& 26331\\
majorité dur & 2003& 2332& 2500& 1000& 1003& 18346\\
sondeur & 2670& 1998& 2503& 1003& 1002& 19192\\
\hline
\end{tabular}
\end{center}
Score cumulé du joueur 1 sur 1000 itérations.

lignes : joueur 1 --- colonnes : joueur 2
\end{table}

\subsection{Conception}
Cette première partie pose assez peu de problèmes de conception, 
le principal étant celui de la représentation des stratégies.
Nous avons décidé de les représenter par une fonction de décision, qui choisit une action
(coopérer ou trahir) selon ce qui s'est passé lors des parties précédentes.

Pour pouvoir manipuler les stratégies comme paramètre dans des fonctions d'ordre supérieur, 
nous avons choisit la signature commune suivante pour toutes les stratégies :
\begin{verbatim}
action (*strategy)(int n_played, action *hist, int n_coop)
\end{verbatim}

Les paramètres sont :
\begin{itemize}
\item \verb|n_played| : le nombre de parties jouées.
\item \verb|hist| : l'historique des actions de l'adversaire.
\item \verb|n_coop| : le nombre de parties durant lesquelles l'adversaire a coopéré.
\end{itemize}
Le choix de ces paramètres permet d'implémenter efficacement (en temps constant)
toutes les stratégies proposées. Bien sûr, \verb|n_coop| est redondant puisque
l'on peut le calculer à partir de \verb|hist|, mais cela impliquerait un surcout
considérable sur un nombre important d'itérations.
On pourrait également réduire \verb|hist|, car les stratégies implémentées n'en
utilisent qu'une partie réduite, mais cela limiterait alors sévèrement la
création de nouvelles stratégies.


\section{Simulation écologique}
\subsection{Usage}
\begin{verbatim}
$ make populations
$ ./populations <iterations> [initial_population]
\end{verbatim}

Ce programme exécute la simulation écologique pour \verb|iterations| générations,
avec des populations initiales toutes de taille \verb|initial_population|,
et crée \verb|populations.tex| contenant le graphe de l'évolution de la taille des populations.
Voir la figure \ref{sim_plot} pour un exemple de résultat.

Le programme tente de compiler le fichier \LaTeX{} avec \verb|pdflatex|, et de l'afficher avec \verb|evince|
(modifiable dans \verb|latex_output.h|).

Le paramètre \verb|initial_population| est optionnel. S'il n'est pas fournit, le programme travaille
alors avec des proportions de population réelles, au lieu de tailles de populations discrètes.
Le résultat correspond alors au comportement limite, pour des populations grandes.

\begin{figure}
\caption{Simulation écologique}
\label{sim_plot}
\begin{center}
\begin{tikzpicture}
\begin{axis}[
    title={Évolution des populations},
    xlabel={génération},
    ylabel={taille des populations},
    ymin=0,xmin=0,
    cycle list name=color list,
    legend style={
        legend pos=outer north east,
    },
    legend entries={
        gent,
        méch,
        d-d,
        méf,
        d-d dur,
        ranc,
        p gent,
        p méch,
        maj mou,
        maj dur,
        sond,
    }]
    \addplot table [x=gen,y=g] {populations.dat};
    \addplot table [x=gen,y=m] {populations.dat};
    \addplot table [x=gen,y=dd] {populations.dat};
    \addplot table [x=gen,y=mf] {populations.dat};
    \addplot table [x=gen,y=ddd] {populations.dat};
    \addplot table [x=gen,y=r] {populations.dat};
    \addplot table [x=gen,y=pg] {populations.dat};
    \addplot table [x=gen,y=pm] {populations.dat};
    \addplot table [x=gen,y=mm] {populations.dat};
    \addplot table [x=gen,y=md] {populations.dat};
    \addplot table [x=gen,y=s] {populations.dat};
\end{axis}
\end{tikzpicture}
\end{center}
\end{figure}

\newpage
\section{Simulation distribuée}
\subsection{Usage}
\subsubsection*{résumé}
Compilation :
\begin{verbatim}
$ make
\end{verbatim}

\verb|./town| simule une ville, et \verb|./monitor| contrôle l'évolution de la population de plusieurs villes en temps réel.
Les scripts \verb|deploy_all|, \verb|deploy_custom| sont des exemples de déploiement sur les machines de la salle 411.

\subsubsection{Simulation d'une ville}
L'exécutable \verb|town| simule une ville, avec la possibilité de modifier les stratégies autorisées,
les valeurs des récompenses, et les populations initiales. Par défaut, l'évolution des populations
est affichées sur la sortie standard.

Par exemple :
\begin{verbatim}
$ ./town -p 100 -p dd:200 -d m,pg -r 2,8,0,4
\end{verbatim}
lance la simulation avec les options :
\begin{description}
\item[\tt{-p 100}] : population initiale de 100 pour toutes les stratégies.
\item[\tt{-p dd:200}] : population initiale de 200 pour la stratégie `donnant-donnant'.
\item[\tt{-d m,pg}] : les stratégies `méchante' et `périodique gentille' sont interdites.
\item[\tt{-r 2,8,0,4}] : récompenses $P=2$, $T=8$, $D=0$, $C=4$.
\end{description}

La totalité des options est décrite dans
\begin{verbatim}
$ ./town --help
\end{verbatim}

Les abréviations utilisées pour les noms de stratégies sont décrites par
\begin{verbatim}
$ ./town --names
\end{verbatim}

\subsubsection{Moniteur}
L'exécutable \verb|monitor| sert à contrôler l'évolution de la population de plusieurs villes sur des machines distantes.

Utilisation :
\begin{verbatim}
$ ./monitor [HOST...]
\end{verbatim}
Chaque paramètre \verb|HOST| doit être de la forme \verb|HOSTNAME:PORT|.
Le programme tente de se connecter à \verb|HOSTNAME| sur le port \verb|PORT| pour afficher l'état de la population simulée sur \verb|HOSTNAME|.
Pour cela, \verb|town| doit avoir été lancé sur \verb|HOSTNAME| avec l'option \verb|-m PORT|.

\subsubsection{Scripts de déploiement}

\end{document}
